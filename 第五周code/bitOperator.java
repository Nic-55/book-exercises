public class bitOperator {
	public static void main(String[] args) {
		//位运算符讲解
		//1. 先得到2的补码,因为计算机以补码的方式来运算
		//先得到2的原码:00000000 00000000 00000000 0000010 
		//这里是因为一个byte等于8个bit,一个int占4个byte,也就是4*8个bit 
		//又因为正数的原码补码和反码都是一样的,三码合一,所以2这个int的补码也是这个
		//2. 再得到3的补码
		//3的原码是:00000000 00000000 00000000 00000011
		//同上原因,三的补码也是这个
		//3.进行按位与 & 
		//00000000 00000000 00000000 00000010
		//00000000 00000000 00000000 00000011
		//每一位相对应,结果就是:00000000 00000000 00000000 00000010(此时还是补码)
		//因为看结果要看原码,所以把它转成原码
		//因为符号位是0,证明是正数,所以这个补码也是自己的原码
		//转回十进制,就是2
				System.out.println(2&3);



		//第二题
				System.out.println(~-2);
				//先得到-2的原码
				//10000000 00000000 00000000 00000010
				//因为是以补码方式运行,所以先求补码
				//因为服输的补码是反码+1,所以先求补码
				//负数的反码=原码符号位不变,其他位取反(也就是0变1,1变0)
				//所以-2的反码就是11111111 11111111 11111111 11111101
				//补码就是11111111 11111111 11111111 11111110 (+1,进一位)
				//可以取反了: 00000000 00000000 00000000 00000001(运算后的补码)
				//算后是正数,对应的原码就是它的补码
				//转成十进制就是正1



		//第三题
				System.out.println(2|3);
				//2的原码和补码: 00000000 00000000 00000000 00000010
				//3的原码和补码: 00000000 00000000 00000000 00000011
				//按位或:       00000000 00000000 00000000 00000011
				//结果是3


	    //第四题
				System.out.println(2^3);
				//2的原码和补码: 00000000 00000000 00000000 00000010
				//3的原码和补码: 00000000 00000000 00000000 00000011
				//按位异或:     00000000 00000000 00000000 00000001
				//结果是1


		//第五题
				int a = 1 >> 2;
				int c = 1 << 2;  
				System.out.println(a);
				System.out.println(c);
				System.out.println(4 << 3); //4*2*2*2 = 32
				System.out.println(15 >> 2); //15/2/2 = 3

				






	}
}